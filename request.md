{ Delete the current broken fill-in-the-blank functionality and replace it with a new working API.

API Purpose

Create a Fill in the Blank API that uses prior information from syntax memoized verses (manually captured).

Based on memorized results, generate SyntaxLabs study flows.

Core Logic

Study modes: start with Fill in the Blank only.

Pull results from verse memorization:

If the user failed a word, capture it.

Those failed words become the blanks in Fill in the Blank practice.

Progress should follow top-to-bottom, left-to-right order of the verse.

Connect this API to the round/word count API so counts update correctly.

Bug Fixes

Ensure blanks never get stuck (must always advance).

If the same word appears multiple times, filling one blank should only complete that blank, not the others.

UI & API Sync

Underline blanks: must appear when API marks a word as blank.

Green highlights: must apply immediately when the API confirms a correct word capture.

Purple gradient highlights: must show when the API signals an active blank being filled.

All UI updates should be triggered by API state changes so the display always stays in sync with the data flow.

Deliverable

Replace old fill-in-the-blank code with this new API.

Confirm working integration with:

Round/word count API

SyntaxLabs study flow

UI effects (underline, green highlight, purple gradient) updating correctly with API state. }

---

## **Mission Briefing: Standard Operating Protocol**

You will now execute this request in full compliance with your **AUTONOMOUS PRINCIPAL ENGINEER - OPERATIONAL DOCTRINE.** Each phase is mandatory. Deviations are not permitted.

---

## **Phase 0: Reconnaissance & Mental Modeling (Read-Only)**

-   **Directive:** Perform a non-destructive scan of the entire repository to build a complete, evidence-based mental model of the current system architecture, dependencies, and established patterns.
-   **Output:** Produce a concise digest (‚â§ 200 lines) of your findings. This digest will anchor all subsequent actions.
-   **Constraint:** **No mutations are permitted during this phase.**

---

## **Phase 1: Planning & Strategy**

-   **Directive:** Based on your reconnaissance, formulate a clear, incremental execution plan.
-   **Plan Requirements:**
    1.  **Restate Objectives:** Clearly define the success criteria for this request.
    2.  **Identify Full Impact Surface:** Enumerate **all** files, components, services, and user workflows that will be directly or indirectly affected. This is a test of your system-wide thinking.
    3.  **Justify Strategy:** Propose a technical approach. Explain *why* it is the best choice, considering its alignment with existing patterns, maintainability, and simplicity.
-   **Constraint:** Invoke the **Clarification Threshold** from your Doctrine only if you encounter a critical ambiguity that cannot be resolved through further research.

---

## **Phase 2: Execution & Implementation**

-   **Directive:** Execute your plan incrementally. Adhere strictly to all protocols defined in your **Operational Doctrine.**
-   **Core Protocols in Effect:**
    -   **Read-Write-Reread:** For every file you modify, you must read it immediately before and immediately after the change.
    -   **Command Execution Canon:** All shell commands must be executed using the mandated safety wrapper.
    -   **Workspace Purity:** All transient analysis and logs remain in-chat. No unsolicited files.
    -   **System-Wide Ownership:** If you modify a shared component, you are **MANDATED** to identify and update **ALL** its consumers in this same session.

---

## **Phase 3: Verification & Autonomous Correction**

-   **Directive:** Rigorously validate your changes with fresh, empirical evidence.
-   **Verification Steps:**
    1.  Execute all relevant quality gates (unit tests, integration tests, linters, etc.).
    2.  If any gate fails, you will **autonomously diagnose and fix the failure,** reporting the cause and the fix.
    3.  Perform end-to-end testing of the primary user workflow(s) affected by your changes.

---

## **Phase 4: Mandatory Zero-Trust Self-Audit**

-   **Directive:** Your primary implementation is complete, but your work is **NOT DONE.** You will now reset your thinking and conduct a skeptical, zero-trust audit of your own work. Your memory is untrustworthy; only fresh evidence is valid.
-   **Audit Protocol:**
    1.  **Re-verify Final State:** With fresh commands, confirm the Git status is clean, all modified files are in their intended final state, and all relevant services are running correctly.
    2.  **Hunt for Regressions:** Explicitly test at least one critical, related feature that you did *not* directly modify to ensure no unintended side effects were introduced.
    3.  **Confirm System-Wide Consistency:** Double-check that all consumers of any changed component are working as expected.

---

## **Phase 5: Final Report & Verdict**

-   **Directive:** Conclude your mission with a single, structured report.
-   **Report Structure:**
    -   **Changes Applied:** A list of all created or modified artifacts.
    -   **Verification Evidence:** The commands and outputs from your autonomous testing and self-audit, proving the system is healthy.
    -   **System-Wide Impact Statement:** A confirmation that all identified dependencies have been checked and are consistent.
    -   **Final Verdict:** Conclude with one of the two following statements, exactly as written:
        -   `"Self-Audit Complete. System state is verified and consistent. No regressions identified. Mission accomplished."`
        -   `"Self-Audit Complete. CRITICAL ISSUE FOUND. Halting work. [Describe issue and recommend immediate diagnostic steps]."`
-   **Constraint:** Maintain an inline TODO ledger using ‚úÖ / ‚ö†Ô∏è / üöß markers throughout the process.